from typing import Callable, Any

from http_framework.blueprint import Blueprint
from http_framework.middleware import Middleware
from http_framework.request import Request
from http_framework.response import Response
from http_framework.routing import RoutingMixin
from http_framework.utils import Trie

HandlerType = Callable[..., Any]


class HttpFramework(RoutingMixin):
    """
    The main HTTP framework class.
    """

    def __init__(self) -> None:
        super().__init__()
        self.routes = Trie()
        self.middlewares: list[Middleware] = []

    def add_middleware(self, middleware: Middleware) -> None:
        """
        Adds a middleware component to the framework.

        Parameters:
            - middleware: The middleware instance to add.

        Raises:
            - TypeError: If the middleware is not an instance of the Middleware class.
        """

        if not isinstance(middleware, Middleware):
            raise TypeError("Middleware must be an instance of Middleware class.")

        self.middlewares.append(middleware)

    def register_blueprint(self, blueprint: Blueprint) -> None:
        """
        Registers a blueprint to the app.

        Parameters:
            - blueprint: The blueprint instance to register.

        Raises:
            - TypeError: If the blueprint is not an instance of the Blueprint class.
        """

        if not isinstance(blueprint, Blueprint):
            raise TypeError("Blueprint must be an instance of Blueprint class.")

        for path, methods, view_func in blueprint.route_configurations:
            path = blueprint.prefix + (
                path if isinstance(path, str) else "/".join(path)
            )
            for method in methods:
                self.route(path, method)(view_func)

    @staticmethod
    def default_response() -> Response:
        """
        Returns a default response when no matching route is found.

        Returns:
            A Response object containing the default error message and status code.
        """

        response = Response("404 Not Found", status=404)
        response.set_header("Content-Type", "text/plain")
        return response

    @staticmethod
    def handle_error(*_, **__) -> Response:
        """
        Handles errors in the application.

        Returns:
            A Response object containing the error message and status code.
        """

        response = Response("Internal Server Error", status=500)
        response.set_header("Content-Type", "text/plain")
        return response

    def dispatch_request(self, request: Request) -> Response:
        """
        Dispatches the request to the appropriate handler based on the path.

        Parameters:
            - request: The request object.

        Returns:
            A Response object generated by the matching handler or a default response.
        """

        path_parts = self._split_path(request.path)
        handler, params = self.routes.match(path_parts, request.method)
        if handler:
            return handler(request, **params)

        return self.default_response()

    def __call__(
        self, environ: dict[str, Any], start_response: Callable
    ) -> list[bytes]:
        """
        The WSGI application.

        Parameters:
            - environ: The WSGI environment dictionary.
            - start_response: The WSGI start_response function.

        Returns:
            A list of bytes representing the response body.
        """

        request = Request(environ)

        for middleware in self.middlewares:
            request = middleware.process_request(request)

        try:
            response = self.dispatch_request(request)
        except Exception as e:
            response = self.handle_error(request, e)

        for middleware in reversed(self.middlewares):
            response = middleware.process_response(request, response)

        if not isinstance(response.body, bytes):
            response_body = response.body.encode("utf-8")
        else:
            response_body = response.body

        start_response(response.get_status(), response.headers)
        return [response_body]
